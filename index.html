<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>만다라 그림판 v1.2</title>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;700&display=swap" rel="stylesheet">
    <script src="https://unpkg.com/lucide@latest"></script>
    <style>
        :root {
            --bg-color: #c0c0c0;
            --win-border: #000000;
            --accent: #0000aa;
            --orange-thumb: #808080; 
        }

        body {
            background-color: #555;
            background-image: radial-gradient(#666 15%, transparent 16%), radial-gradient(#666 15%, transparent 16%);
            background-size: 20px 20px;
            background-position: 0 0, 10px 10px;
            font-family: 'Noto Sans KR', sans-serif;
            display: flex;
            min-height: 100vh;
            margin: 0;
            overflow: auto;
            user-select: none;
        }

        .window-container {
            width: auto;
            height: auto;
            background-color: var(--bg-color);
            border: 2px solid var(--win-border);
            box-shadow: 8px 8px 0px rgba(0,0,0,0.5);
            display: flex;
            flex-direction: column;
            position: relative;
            margin: auto;
            flex-shrink: 0;
        }

        .title-bar {
            background: linear-gradient(90deg, #000080, #1084d0);
            color: white;
            padding: 4px 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 1.2rem;
            border-bottom: 2px solid var(--win-border);
        }

        .menu-bar {
            display: flex;
            padding: 6px;
            background-color: var(--bg-color);
            border-bottom: 2px solid var(--win-border);
            font-size: 0.9rem;
            align-items: center;
            flex-wrap: nowrap;
            gap: 5px;
        }

        .menu-item {
            padding: 4px 6px;
            cursor: pointer;
            border: 1px solid transparent;
        }
        
        .menu-item:hover {
            background-color: var(--accent);
            color: white;
        }

        .menu-separator {
            width: 2px;
            height: 20px;
            background-color: #888;
            border-right: 1px solid #fff;
            margin: 0 2px;
        }

        .slider-group {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        input[type="range"] {
            width: 50px; 
            height: 10px;
            cursor: pointer;
            vertical-align: middle;
            -webkit-appearance: none;
            background: transparent;
            border: 1px solid #000;
            border-radius: 5px;
        }

        input[type="range"]::-webkit-slider-runnable-track {
            width: 100%;
            height: 10px;
            cursor: pointer;
            background: linear-gradient(to right, var(--orange-thumb) 0%, #e0e0e0 0%);
            border-radius: 5px;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 12px;
            height: 12px;
            background: var(--orange-thumb);
            border-radius: 50%;
            cursor: pointer;
            border: 1px solid #000;
            box-shadow: 1px 1px 0 rgba(0,0,0,0.5);
            margin-top: -1px;
        }

        .workspace {
            display: flex;
            padding: 10px;
            gap: 10px;
            background-color: #e0e0e0;
            align-items: flex-start;
        }

        .toolbar {
            width: 60px;
            display: flex;
            flex-direction: column;
            gap: 6px; 
            align-items: center;
        }

        .tool-btn {
            width: 54px;
            height: 36px; /* 높이를 36px로 수정 */
            background-color: var(--bg-color);
            border: 2px outset #fff;
            box-shadow: 1px 1px 0 #000;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            transition: all 0.1s;
        }

        .tool-btn:active, .tool-btn.active {
            border: 2px inset #fff;
            background-color: #ddd;
            transform: translate(1px, 1px);
        }

        .color-area {
            width: 100%;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 5px;
            padding-top: 6px;
            justify-items: center; 
            margin-top: 2px; 
        }

        .toolbar-separator {
            width: 100%;
            height: 2px;
            background-color: #888;
            border-bottom: 1px solid #fff;
            margin: 5px 0 0 0;
        }

        .color-swatch, .color-select-btn, .bg-btn {
            width: 25px; 
            height: 25px; 
            border: 2px solid #000;
            cursor: pointer;
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            box-sizing: border-box; 
        }
        
        .color-swatch.active {
            box-shadow: 0 0 0 2px #fff, 0 0 0 4px #000;
            z-index: 1;
        }

        .color-select-btn {
            background-color: #ff66cc;
        }

        .bg-btn {
            background-color: #ffffff;
            font-weight: bold;
            font-size: 14px;
            line-height: 1;
            color: #000;
        }

        .color-plus-icon {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white; 
            text-shadow: 0 0 2px black;
            font-weight: bold;
            font-size: 16px;
            pointer-events: none;
        }

        .canvas-wrapper {
            width: 500px;
            height: 500px;
            background-color: #fff;
            border: 2px inset #fff;
            position: relative;
            cursor: crosshair;
            overflow: hidden;
            box-shadow: inset 2px 2px 5px rgba(0,0,0,0.1);
            flex-shrink: 0;
            touch-action: none;
        }

        canvas {
            display: block;
            image-rendering: pixelated; 
            touch-action: none;
        }

        .status-bar {
            padding: 4px 8px;
            background-color: var(--bg-color);
            border-top: 2px solid var(--win-border);
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.85rem;
        }

        .modal-overlay {
            display: none;
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.3); 
            z-index: 99;
        }

        .retro-modal {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white; 
            border: 2px solid black; 
            padding: 10px;
            text-align: center;
            box-shadow: 10px 10px 0 rgba(0,0,0,0.5); 
            z-index: 100;
            min-width: 200px;
            font-family: 'Noto Sans KR', sans-serif;
        }

        .retro-modal h3 {
            margin: 5px 0 15px 0;
            font-size: 1.1rem;
            font-weight: bold;
        }

        .retro-btn {
            padding: 5px 20px;
            margin: 10px 5px 5px 5px;
            background: #c0c0c0;
            border: 2px outset #fff;
            cursor: pointer;
            font-family: inherit;
            font-size: 0.9rem;
            min-width: 60px;
        }
        
        .retro-btn:active {
            border: 2px inset #fff;
            background: #aaaaaa;
        }

        .color-picker-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            padding: 10px;
        }

        .color-picker-row {
            display: flex;
            align-items: center;
            gap: 10px;
            width: 100%;
            justify-content: center;
        }

        .color-input-wrapper {
            position: relative;
            width: 150px;
            height: 150px;
            border: 2px inset #fff;
            background: #fff;
            overflow: hidden;
        }

        .color-input-wrapper input[type="color"] {
            position: absolute;
            top: -10px;
            left: -10px;
            width: calc(100% + 20px);
            height: calc(100% + 20px);
            border: none;
            cursor: pointer;
            padding: 0;
        }

        .color-preview-box {
            width: 60px;
            height: 60px;
            border: 2px solid #000;
            box-shadow: inset 2px 2px 4px rgba(0,0,0,0.2);
        }

        .color-hex-input {
            width: 80px;
            padding: 4px 6px;
            font-family: monospace;
            font-size: 14px;
            text-transform: uppercase;
            border: 2px inset #fff;
            text-align: center;
        }

        .color-picker-label {
            font-size: 0.85rem;
            color: #333;
        }

        .loading-overlay {
            display: none;
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(255,255,255,0.8);
            z-index: 200;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            font-size: 1.2rem;
            color: #000;
            text-align: center;
        }
    </style>
</head>
<body oncontextmenu="return false;">

    <div class="window-container">
        <div class="title-bar">
            <div style="display: flex; gap: 10px; align-items: center;"><span>만다라 그림판 v1.2</span></div>
            <button class="retro-btn" onclick="toggleFullScreen()" style="width: 24px; height: 24px; padding: 0; display: flex; justify-content: center; align-items: center; min-width: unset;">
                <i data-lucide="maximize" style="width: 14px; height: 14px;"></i>
            </button>
        </div>

        <div class="menu-bar">
            <div class="menu-item" onclick="confirmNew()">새로 만들기</div>
            <div class="menu-separator"></div>
            <div class="menu-item" onclick="saveJpg()">JPG 저장</div>
            <div class="menu-separator"></div>
            <div class="slider-group">
                <span>굵기:</span>
                <input type="range" id="size-slider" min="1" max="30" value="3" oninput="updateSize(this.value)" title="브러시 크기">
                <span id="size-val" style="width: 20px;">3</span>
            </div>
            <div class="menu-separator"></div>
            <div class="slider-group">
                <span>분할:</span>
                <input type="range" id="division-slider" min="1" max="20" value="1" oninput="updateDivision(this.value)" title="만다라 분할">
                <span id="division-val" style="width: 20px;">1</span>
            </div>
            <div class="menu-separator"></div>
            <div class="slider-group">
                <label style="display: flex; align-items: center; gap: 2px; cursor: pointer;">
                    <input type="checkbox" id="mirror-mode" checked onchange="updateMirrorMode(this.checked)" style="width: 14px; height: 14px; cursor: pointer;">
                    <span>거울모드</span>
                </label>
            </div>
        </div>

        <div class="workspace">
            <div class="toolbar">
                <button class="tool-btn active" id="btn-pen" onclick="selectTool('pen')" title="펜">
                    <i data-lucide="pencil"></i>
                </button>
                <button class="tool-btn" id="btn-marker" onclick="selectTool('marker')" title="마커 (반투명)">
                    <i data-lucide="highlighter"></i>
                </button>
                <button class="tool-btn" id="btn-bucket" onclick="selectTool('bucket')" title="페인트통">
                    <i data-lucide="paint-bucket"></i>
                </button>
                <button class="tool-btn" id="btn-eraser" onclick="selectTool('eraser')" title="지우개">
                    <i data-lucide="eraser"></i>
                </button>
                <button class="tool-btn" onclick="confirmClear()" title="전체 삭제">
                    <i data-lucide="trash-2" style="color:black;"></i>
                </button>
                <button class="tool-btn" onclick="loadImageBackground()" title="배경 이미지 불러오기">
                    <i data-lucide="camera" style="color:black;"></i>
                </button>
                <button class="tool-btn" onclick="undo()" title="실행 취소">
                    <i data-lucide="undo-2"></i>
                </button>
                <button class="tool-btn" onclick="redo()" title="다시 실행">
                    <i data-lucide="redo-2"></i>
                </button>

                <div class="toolbar-separator"></div>

                <div class="color-area">
                    <div class="color-swatch active" style="background: #000000;" onclick="setColor('#000000', this)" title="검정"></div>
                    <div class="color-swatch" style="background: #ffffff; border: 2px solid #ccc;" onclick="setColor('#ffffff', this)" title="흰색"></div>
                    <div class="color-swatch" style="background: #ff3333;" onclick="setColor('#ff3333', this)" title="빨강"></div>
                    <div class="color-swatch" style="background: #ff8c00;" onclick="setColor('#ff8c00', this)" title="주황"></div>
                    <div class="color-swatch" style="background: #ffcc00;" onclick="setColor('#ffcc00', this)" title="노랑"></div>
                    <div class="color-swatch" style="background: #33cc33;" onclick="setColor('#33cc33', this)" title="초록"></div>
                    <div class="color-swatch" style="background: #3333ff;" onclick="setColor('#3333ff', this)" title="파랑"></div>
                    <div class="color-swatch" style="background: #9933ff;" onclick="setColor('#9933ff', this)" title="보라"></div>

                    <div class="color-select-btn" id="custom-swatch" style="background: #ff66cc;" onclick="openDirectColorPicker()" title="자유 색상 선택 (+)">
                        <span class="color-plus-icon">+</span>
                    </div>
                    <div class="bg-btn" onclick="openDirectBgColorPicker()" title="배경색 변경 (B)">
                        B
                    </div>
                </div>
            </div>

            <div class="canvas-wrapper" id="canvas-container">
                <canvas id="drawing-canvas" width="500" height="500"></canvas>
                <!-- 자유 색상 선택용 (캔버스 중앙에 배치, picker 크기 고려 오프셋) -->
                <input type="color" id="direct-color-picker" style="position: absolute; top: calc(50% - 120px); left: calc(50% - 115px); opacity: 0; width: 1px; height: 1px; pointer-events: none;">
            </div>
        </div>

        <div class="status-bar">
            <span id="status-text">500X500 캔버스 (Full Color)</span>
            <span>KSMS APPS</span>
        </div>
        
        <div class="modal-overlay" id="overlay"></div>

        <div class="retro-modal" id="new-modal">
            <p style="margin: 20px 0;">모든 그림을 지우고<br>새로 만드시겠습니까?</p>
            <div>
                <button class="retro-btn" onclick="createNewCanvas()">네</button>
                <button class="retro-btn" onclick="closeModal()">아니오</button>
            </div>
        </div>

        <div class="retro-modal" id="clear-modal">
            <p style="margin: 20px 0;">정말로 모든 그림을<br>지우시겠습니까?<br><span style="font-size:0.8rem; color:#666;">(배경은 유지됩니다)</span></p>
            <div>
                <button class="retro-btn" onclick="clearCanvas()">네</button>
                <button class="retro-btn" onclick="closeModal()">아니오</button>
            </div>
        </div>

        <div class="retro-modal" id="palette-modal">
            <h3 id="palette-modal-title">색상 선택</h3>
            <div class="color-picker-container">
                <div class="color-input-wrapper">
                    <input type="color" id="color-picker-input" value="#ff66cc" onchange="onColorPickerChange(this.value)" oninput="onColorPickerChange(this.value)">
                </div>
                <div class="color-picker-row">
                    <div>
                        <div class="color-picker-label">선택 색상</div>
                        <div class="color-preview-box" id="color-preview"></div>
                    </div>
                    <div>
                        <div class="color-picker-label">HEX 값</div>
                        <input type="text" class="color-hex-input" id="color-hex-input" value="#FF66CC" maxlength="7" onchange="onHexInputChange(this.value)">
                    </div>
                </div>
            </div>
            <div>
                <button class="retro-btn" onclick="applyPickedColor()">선택</button>
                <button class="retro-btn" onclick="closeModal()">취소</button>
            </div>
        </div>

        <div class="loading-overlay" id="loading-overlay">
            <div id="loading-text">처리 중...</div>
            <div style="font-size: 0.9rem; margin-top: 10px;">잠시만 기다려 주세요.</div>
        </div>
    </div>

    <input type="file" id="bg-image-input" accept="image/*" style="display: none;">

    <script>
        lucide.createIcons();

        // --- 변수 및 설정 ---
        const canvas = document.getElementById('drawing-canvas');
        const ctx = canvas.getContext('2d');
        const container = document.getElementById('canvas-container');
        const statusText = document.getElementById('status-text');
        const bgImageInput = document.getElementById('bg-image-input');
        const loadingOverlay = document.getElementById('loading-overlay');
        const loadingText = document.getElementById('loading-text');
        
        // --- 렌더링을 위한 오프스크린 캔버스 추가 (그림 레이어) ---
        const offscreenCanvas = document.createElement('canvas');
        offscreenCanvas.width = 500;
        offscreenCanvas.height = 500;
        const offCtx = offscreenCanvas.getContext('2d');
        
        let isDrawing = false;
        let points = []; 
        let strokes = []; 
        let removedStrokes = []; 
        let lastClearSnapshot = null;
        let lastClearRedoSnapshot = null;
        
        let currentTool = 'pen';
        let currentColor = '#000000';
        let currentSize = 3; 
        let currentDivision = 1;
        let mirrorMode = true;
        const DEFAULT_BG_COLOR = '#ffffff'; 
        let canvasBgColor = DEFAULT_BG_COLOR;
        let backgroundImage = null;
        
        let colorPickMode = 'bg'; 
        let customSwatchColor = '#ff66cc'; 
        let customSwatchElement = document.getElementById('custom-swatch');

        let activePointers = new Set();

        // --- 풀컬러 피커 관련 변수 및 함수 ---
        let pickedColor = '#ff66cc';
        
        function onColorPickerChange(color) {
            pickedColor = color;
            document.getElementById('color-preview').style.backgroundColor = color;
            document.getElementById('color-hex-input').value = color.toUpperCase();
        }
        
        function onHexInputChange(value) {
            // HEX 값 유효성 검사
            let hex = value.trim();
            if (!hex.startsWith('#')) hex = '#' + hex;
            
            // 유효한 HEX 색상인지 확인
            if (/^#[0-9A-Fa-f]{6}$/.test(hex)) {
                pickedColor = hex;
                document.getElementById('color-picker-input').value = hex;
                document.getElementById('color-preview').style.backgroundColor = hex;
                document.getElementById('color-hex-input').value = hex.toUpperCase();
            }
        }
        
        function applyPickedColor() {
            if (colorPickMode === 'bg') {
                canvasBgColor = pickedColor;
                backgroundImage = null; 
                render();
            } else {
                customSwatchColor = pickedColor; 
                customSwatchElement.style.backgroundColor = pickedColor; 
                setColor(pickedColor, customSwatchElement);
                customSwatchElement.classList.add('active'); 
            }
            closeModal();
        }

        // --- 직접 색상 선택 (모달 없이 한 번에) ---
        const directColorPicker = document.getElementById('direct-color-picker');
        let isColorPickerOpen = false; // 색상 선택창 열림 상태
        let directPickerMode = 'brush'; // 'brush' 또는 'bg'
        
        function openDirectColorPicker() {
            directPickerMode = 'brush';
            directColorPicker.value = customSwatchColor;
            isColorPickerOpen = true;
            directColorPicker.click();
        }
        
        function openDirectBgColorPicker() {
            directPickerMode = 'bg';
            directColorPicker.value = canvasBgColor;
            isColorPickerOpen = true;
            directColorPicker.click();
        }
        
        directColorPicker.addEventListener('input', function(e) {
            const color = e.target.value;
            // 브러시 색상만 실시간 미리보기 (배경색은 성능 문제로 제외)
            if (directPickerMode === 'brush') {
                customSwatchColor = color;
                customSwatchElement.style.backgroundColor = color;
                setColor(color, customSwatchElement);
                customSwatchElement.classList.add('active');
            }
        });
        
        // 색상 선택 완료 시
        directColorPicker.addEventListener('change', function(e) {
            const color = e.target.value;
            // 배경색은 선택 완료 시에만 적용
            if (directPickerMode === 'bg') {
                canvasBgColor = color;
                backgroundImage = null;
                render();
            }
            setTimeout(() => { isColorPickerOpen = false; }, 100);
        });
        
        // 포커스 잃을 때도 닫힘 처리
        directColorPicker.addEventListener('blur', function(e) {
            setTimeout(() => { isColorPickerOpen = false; }, 100);
        });


        // --- 수정된 렌더링 로직 (만다라 패턴 적용, 떨림 제거) ---
        function render() {
            // 1. 메인 캔버스에 배경(종이/사진) 그리기
            ctx.globalCompositeOperation = 'source-over';
            ctx.fillStyle = canvasBgColor;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            if (backgroundImage) {
                ctx.drawImage(backgroundImage, 0, 0, canvas.width, canvas.height);
            }
            
            // 2. 오프스크린 캔버스(그림 레이어) 초기화 (완전 투명하게)
            offCtx.clearRect(0, 0, offscreenCanvas.width, offscreenCanvas.height);
            offCtx.lineCap = 'round';
            offCtx.lineJoin = 'round';

            // 3. 그림 레이어에 모든 선 그리기 (만다라 패턴)
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;

            strokes.forEach(stroke => {
                if (stroke.type === 'action') return; 
                if (stroke.type === 'fill') {
                    // 페인트통 fill 작업 재생: 현재까지의 그림을 합성 후 fill 실행
                    ctx.drawImage(offscreenCanvas, 0, 0);
                    offCtx.clearRect(0, 0, offscreenCanvas.width, offscreenCanvas.height);
                    floodFill(stroke.x, stroke.y, stroke.color);
                    return;
                }
                if (!stroke.points || stroke.points.length < 2) return;

                const division = stroke.division || 1;
                const useMirror = (stroke.mirror !== undefined) ? stroke.mirror : false;
                const angleStep = (Math.PI * 2) / division;

                // 지우개: 투명하게 지우기 (destination-out)
                if (stroke.tool === 'eraser') {
                    offCtx.globalCompositeOperation = 'destination-out';
                    offCtx.strokeStyle = '#000000';
                    offCtx.globalAlpha = 1.0;
                } else {
                    offCtx.globalCompositeOperation = 'source-over';
                    offCtx.strokeStyle = stroke.color;
                    offCtx.globalAlpha = (stroke.tool === 'marker') ? 0.5 : 1.0;
                }
                
                offCtx.lineWidth = stroke.size;

                // 만다라 패턴 그리기
                for (let i = 0; i < division; i++) {
                    const angle = angleStep * i;
                    
                    // 회전 그리기
                    offCtx.beginPath();
                    for (let j = 0; j < stroke.points.length; j++) {
                        const p = stroke.points[j];
                        
                        const relX = p.x - centerX;
                        const relY = p.y - centerY;
                        
                        const rotatedX = relX * Math.cos(angle) - relY * Math.sin(angle);
                        const rotatedY = relX * Math.sin(angle) + relY * Math.cos(angle);
                        
                        const finalX = rotatedX + centerX;
                        const finalY = rotatedY + centerY;
                        
                        if (j === 0) {
                            offCtx.moveTo(finalX, finalY);
                        } else {
                            offCtx.lineTo(finalX, finalY);
                        }
                    }
                    offCtx.stroke();
                    
                    // 거울모드: 대칭 그리기 추가
                    if (useMirror) {
                        offCtx.beginPath();
                        for (let j = 0; j < stroke.points.length; j++) {
                            const p = stroke.points[j];
                            
                            const relX = -(p.x - centerX); // X축 반전
                            const relY = p.y - centerY;
                            
                            const rotatedX = relX * Math.cos(angle) - relY * Math.sin(angle);
                            const rotatedY = relX * Math.sin(angle) + relY * Math.cos(angle);
                            
                            const finalX = rotatedX + centerX;
                            const finalY = rotatedY + centerY;
                            
                            if (j === 0) {
                                offCtx.moveTo(finalX, finalY);
                            } else {
                                offCtx.lineTo(finalX, finalY);
                            }
                        }
                        offCtx.stroke();
                    }
                }
            });
            
            // 4. 현재 그리는 선 미리보기 (실시간)
            if (isDrawing && points.length > 1 && currentTool !== 'bucket') {
                const angleStep = (Math.PI * 2) / currentDivision;
                
                // 지우개 미리보기
                if (currentTool === 'eraser') {
                    offCtx.globalCompositeOperation = 'destination-out';
                    offCtx.strokeStyle = '#000000';
                    offCtx.globalAlpha = 1.0;
                } else {
                    offCtx.globalCompositeOperation = 'source-over';
                    offCtx.strokeStyle = currentColor;
                    offCtx.globalAlpha = (currentTool === 'marker') ? 0.5 : 1.0;
                }
                
                offCtx.lineWidth = currentSize;

                // 만다라 패턴 미리보기
                for (let i = 0; i < currentDivision; i++) {
                    const angle = angleStep * i;
                    
                    // 회전 미리보기
                    offCtx.beginPath();
                    for (let j = 0; j < points.length; j++) {
                        const p = points[j];
                        
                        const relX = p.x - centerX;
                        const relY = p.y - centerY;
                        
                        const rotatedX = relX * Math.cos(angle) - relY * Math.sin(angle);
                        const rotatedY = relX * Math.sin(angle) + relY * Math.cos(angle);
                        
                        const finalX = rotatedX + centerX;
                        const finalY = rotatedY + centerY;
                        
                        if (j === 0) {
                            offCtx.moveTo(finalX, finalY);
                        } else {
                            offCtx.lineTo(finalX, finalY);
                        }
                    }
                    offCtx.stroke();
                    
                    // 거울모드: 대칭 미리보기 추가
                    if (mirrorMode) {
                        offCtx.beginPath();
                        for (let j = 0; j < points.length; j++) {
                            const p = points[j];
                            
                            const relX = -(p.x - centerX);
                            const relY = p.y - centerY;
                            
                            const rotatedX = relX * Math.cos(angle) - relY * Math.sin(angle);
                            const rotatedY = relX * Math.sin(angle) + relY * Math.cos(angle);
                            
                            const finalX = rotatedX + centerX;
                            const finalY = rotatedY + centerY;
                            
                            if (j === 0) {
                                offCtx.moveTo(finalX, finalY);
                            } else {
                                offCtx.lineTo(finalX, finalY);
                            }
                        }
                        offCtx.stroke();
                    }
                }
            }
            
            // 5. 그림 레이어를 배경 레이어 위에 합성
            ctx.drawImage(offscreenCanvas, 0, 0);
        }

        // --- 페인트통 기능 (Flood Fill) ---
        function floodFill(x, y, fillColor) {
            x = Math.floor(x);
            y = Math.floor(y);
            
            // 현재 캔버스의 이미지 데이터 가져오기
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            
            // 클릭한 위치의 색상
            const targetColor = getPixelColor(data, x, y);
            
            // 채울 색상을 RGB로 변환
            const fill = hexToRgb(fillColor);
            
            // 같은 색이면 채우지 않음
            if (colorsMatch(targetColor, fill)) return;
            
            // BFS를 사용한 Flood Fill
            const queue = [{x, y}];
            const visited = new Set();
            
            while (queue.length > 0) {
                const {x: cx, y: cy} = queue.shift();
                const key = `${cx},${cy}`;
                
                if (visited.has(key)) continue;
                if (cx < 0 || cx >= canvas.width || cy < 0 || cy >= canvas.height) continue;
                
                const currentColor = getPixelColor(data, cx, cy);
                if (!colorsMatch(currentColor, targetColor)) continue;
                
                visited.add(key);
                setPixelColor(data, cx, cy, fill);
                
                // 4방향 탐색
                queue.push({x: cx + 1, y: cy});
                queue.push({x: cx - 1, y: cy});
                queue.push({x: cx, y: cy + 1});
                queue.push({x: cx, y: cy - 1});
            }
            
            ctx.putImageData(imageData, 0, 0);
        }

        function getPixelColor(data, x, y) {
            const index = (y * canvas.width + x) * 4;
            return {
                r: data[index],
                g: data[index + 1],
                b: data[index + 2],
                a: data[index + 3]
            };
        }

        function setPixelColor(data, x, y, color) {
            const index = (y * canvas.width + x) * 4;
            data[index] = color.r;
            data[index + 1] = color.g;
            data[index + 2] = color.b;
            data[index + 3] = 255;
        }

        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : null;
        }

        function colorsMatch(c1, c2) {
            return c1.r === c2.r && c1.g === c2.g && c1.b === c2.b;
        }

        // --- 그리기 이벤트 ---
        container.addEventListener('pointerdown', startDrawing);
        container.addEventListener('pointermove', draw);
        container.addEventListener('pointerup', stopDrawing);
        container.addEventListener('pointercancel', stopDrawing);

        function startDrawing(e) {
            // 색상 선택창이 열려있으면 그리기 방지
            if (isColorPickerOpen) return;
            
            if (e.pointerType === 'mouse' && e.button !== 0) return;
            e.preventDefault();
            activePointers.add(e.pointerId);
            if (activePointers.size >= 2) { if (isDrawing) { isDrawing = false; points = []; } return; }
            
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const x = (e.clientX - rect.left) * scaleX;
            const y = (e.clientY - rect.top) * scaleY;
            
            // 페인트통 도구일 경우
            if (currentTool === 'bucket') {
                lastClearSnapshot = null;
                lastClearRedoSnapshot = null;
                if (removedStrokes.length > 0) removedStrokes = [];
                
                floodFill(x, y, currentColor);
                strokes.push({
                    type: 'fill',
                    x: x,
                    y: y,
                    color: currentColor
                });
                return;
            }
            
            isDrawing = true;
            try { container.setPointerCapture(e.pointerId); } catch (err) {}

            points = [{x, y}];
            
            lastClearSnapshot = null;
            lastClearRedoSnapshot = null;

            if (removedStrokes.length > 0) removedStrokes = [];
        }

        function draw(e) {
            if (!isDrawing || activePointers.size >= 2) return;
            if (currentTool === 'bucket') return;
            
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const y = (e.clientY - rect.top) * scaleY;
            points.push({x: (e.clientX - rect.left) * scaleX, y: y});
            render();
        }

        function stopDrawing(e) {
            if (e && e.pointerId !== undefined) activePointers.delete(e.pointerId);
            if (!isDrawing) return;
            if (e && e.pointerId) try { container.releasePointerCapture(e.pointerId); } catch (err) {}
            isDrawing = false;
            
            if (points.length > 1 && currentTool !== 'bucket') {
                strokes.push({
                    type: 'stroke', 
                    color: currentColor, 
                    size: parseFloat(currentSize),
                    points: points,
                    tool: currentTool,
                    division: currentDivision,
                    mirror: mirrorMode
                });
            }
            points = [];
            render();
        }

        function updateSliderBackground(sliderId, value, max) {
            const slider = document.getElementById(sliderId);
            if (!slider) return;
            const percentage = (value / max) * 100;
            slider.style.background = `linear-gradient(to right, var(--orange-thumb) 0%, var(--orange-thumb) ${percentage}%, #e0e0e0 ${percentage}%, #e0e0e0 100%)`;
        }

        function selectTool(tool) {
            currentTool = tool;
            document.querySelectorAll('.tool-btn').forEach(btn => btn.classList.remove('active'));
            if (document.getElementById(`btn-${tool}`)) {
                document.getElementById(`btn-${tool}`).classList.add('active');
            }
            let recSize = 3;
            if (tool === 'pen') recSize = 3; 
            if (tool === 'marker') recSize = 15; 
            if (tool === 'bucket') recSize = 3;
            if (tool === 'eraser') recSize = 30; 
            
            document.getElementById('size-slider').value = recSize;
            updateSize(recSize);
        }

        function setColor(color, element) {
            if (currentTool === 'eraser') selectTool('pen');
            currentColor = color;
            document.querySelectorAll('.color-swatch').forEach(sw => sw.classList.remove('active'));
            customSwatchElement.classList.remove('active');
            if(element) element.classList.add('active');
        }

        function updateSize(val) {
            currentSize = val;
            document.getElementById('size-val').innerText = val;
            updateSliderBackground('size-slider', currentSize, 30);
        }

        function updateDivision(val) {
            currentDivision = parseInt(val);
            document.getElementById('division-val').innerText = val;
            updateSliderBackground('division-slider', currentDivision, 20);
        }

        function updateMirrorMode(checked) {
            mirrorMode = checked;
        }

        function openPaletteModal(mode) {
            colorPickMode = mode;
            const modalTitle = document.getElementById('palette-modal-title');
            
            // 현재 색상으로 피커 초기화
            let initialColor;
            if (mode === 'bg') {
                modalTitle.innerText = "배경색 변경 (B)";
                initialColor = canvasBgColor;
            } else { 
                modalTitle.innerText = "색상 선택 (+)";
                initialColor = customSwatchColor;
            }
            
            pickedColor = initialColor;
            document.getElementById('color-picker-input').value = initialColor;
            document.getElementById('color-preview').style.backgroundColor = initialColor;
            document.getElementById('color-hex-input').value = initialColor.toUpperCase();
            
            document.getElementById('overlay').style.display = 'block';
            document.getElementById('palette-modal').style.display = 'block';
        }

        function confirmNew() {
            document.getElementById('overlay').style.display = 'block';
            document.getElementById('new-modal').style.display = 'block';
        }

        function confirmClear() {
            document.getElementById('overlay').style.display = 'block';
            document.getElementById('clear-modal').style.display = 'block';
        }

        function closeModal() {
            document.getElementById('overlay').style.display = 'none';
            document.getElementById('clear-modal').style.display = 'none';
            document.getElementById('new-modal').style.display = 'none'; 
            document.getElementById('palette-modal').style.display = 'none';
        }

        function loadImageBackground() {
            bgImageInput.click();
        }

        bgImageInput.addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (!file) return;

            loadingText.innerText = "배경 처리 중...";
            loadingOverlay.style.display = 'flex';

            const reader = new FileReader();
            reader.onload = function(event) {
                const img = new Image();
                img.onload = function() {
                    const canvasSize = 500;
                    const scale = Math.max(canvasSize / img.width, canvasSize / img.height);
                    const newW = img.width * scale;
                    const newH = img.height * scale;
                    const x = (canvasSize - newW) / 2;
                    const y = (canvasSize - newH) / 2;

                    const tempCanvas = document.createElement('canvas');
                    tempCanvas.width = canvasSize;
                    tempCanvas.height = canvasSize;
                    const tCtx = tempCanvas.getContext('2d');
                    
                    tCtx.fillStyle = '#ffffff';
                    tCtx.fillRect(0,0, canvasSize, canvasSize);
                    
                    tCtx.drawImage(img, x, y, newW, newH);

                    const imageData = tCtx.getImageData(0, 0, canvasSize, canvasSize);
                    const data = imageData.data;

                    for (let i = 0; i < data.length; i += 4) {
                        data[i]     = Math.round(data[i] / 51) * 51;     
                        data[i + 1] = Math.round(data[i + 1] / 51) * 51; 
                        data[i + 2] = Math.round(data[i + 2] / 51) * 51; 
                    }

                    tCtx.putImageData(imageData, 0, 0);

                    const finalImg = new Image();
                    finalImg.onload = function() {
                        backgroundImage = finalImg;
                        canvasBgColor = '#ffffff';
                        render();
                        loadingOverlay.style.display = 'none';
                        statusText.innerText = "500X500 캔버스 (Full Color)";
                    };
                    finalImg.src = tempCanvas.toDataURL();
                };
                img.onerror = function() {
                    loadingOverlay.style.display = 'none';
                    statusText.innerText = "이미지 로드 오류!";
                };
                img.src = event.target.result;
            };
            reader.readAsDataURL(file);
            e.target.value = '';
        });
        
        function clearCanvas() {
            closeModal();
            if (strokes.length > 0) {
                lastClearSnapshot = {
                    strokes: strokes.map(s => ({...s})), 
                    bgImage: backgroundImage, 
                    bgColor: canvasBgColor
                }; 
                lastClearRedoSnapshot = null;
                removedStrokes = []; 
                strokes = []; 
            }
            render();
        }
        
        function createNewCanvas() {
            closeModal();
            lastClearSnapshot = null;
            lastClearRedoSnapshot = null;
            removedStrokes = [];
            
            strokes = []; 
            backgroundImage = null; 
            canvasBgColor = DEFAULT_BG_COLOR; 

            selectTool('pen');
            currentColor = '#000000';
            const initialSwatch = document.querySelector('.color-swatch[style*="#000000"]');
            if (initialSwatch) {
                document.querySelectorAll('.color-swatch').forEach(sw => sw.classList.remove('active'));
                initialSwatch.classList.add('active');
                customSwatchElement.classList.remove('active');
            }
            
            render();
            statusText.innerText = "500X500 캔버스 (Full Color)";
        }
        
        function undo() { 
            if (strokes.length > 0) { 
                removedStrokes.push(strokes.pop());
            } else if (strokes.length === 0 && lastClearSnapshot) {
                strokes = lastClearSnapshot.strokes;
                backgroundImage = lastClearSnapshot.bgImage; 
                canvasBgColor = lastClearSnapshot.bgColor;
                
                lastClearRedoSnapshot = lastClearSnapshot; 
                lastClearSnapshot = null; 
            }
            render(); 
        }

        function redo() { 
            if (removedStrokes.length > 0) { 
                strokes.push(removedStrokes.pop()); 
            } else if (removedStrokes.length === 0 && lastClearRedoSnapshot) {
                strokes = []; 
                lastClearSnapshot = lastClearRedoSnapshot; 
                lastClearRedoSnapshot = null; 
            }
            render(); 
        }

        function saveJpg() {
            loadingText.innerText = "JPG 저장 중...";
            loadingOverlay.style.display = 'flex';
            statusText.innerText = "JPG 저장 중...";

            setTimeout(() => {
                try {
                    const link = document.createElement('a');
                    const now = new Date();
                    
                    const yy = String(now.getFullYear()).slice(-2);
                    const mm = String(now.getMonth() + 1).padStart(2, '0');
                    const dd = String(now.getDate()).padStart(2, '0');
                    const hh = String(now.getHours()).padStart(2, '0');
                    const min = String(now.getMinutes()).padStart(2, '0');
                    const ss = String(now.getSeconds()).padStart(2, '0');
                    
                    link.download = `ksms-${yy}${mm}${dd}-${hh}${min}${ss}.jpg`;
                    link.href = canvas.toDataURL('image/jpeg', 0.95);
                    link.click();
                    
                    loadingOverlay.style.display = 'none';
                    statusText.innerText = "저장 완료!";
                    setTimeout(() => statusText.innerText = "500X500 캔버스 (Full Color)", 3000);
                } catch (e) {
                    loadingOverlay.style.display = 'none';
                    console.error("JPG 생성 실패:", e);
                    statusText.innerText = "저장 실패!";
                }
            }, 100);
        }

        function toggleFullScreen() {
            if (!document.fullscreenElement) document.documentElement.requestFullscreen().catch(e=>{});
            else if (document.exitFullscreen) document.exitFullscreen();
        }

        window.onload = function() {
            document.getElementById('size-slider').value = currentSize;
            updateSize(currentSize);
            
            document.getElementById('division-slider').value = currentDivision;
            updateDivision(currentDivision);

            document.getElementById('mirror-mode').checked = mirrorMode;

            customSwatchElement.style.backgroundColor = customSwatchColor;
            
            const initialSwatch = document.querySelector('.color-swatch[style*="#000000"]');
            if (initialSwatch) {
                setColor('#000000', initialSwatch);
            }

            render();
        }
    </script>
</body>
</html>